## [外键的优点和缺点](#jump1)
## [数据库范式](#jump2)
## [数据库设计分为哪几步](#jump3)
## [MyISAM和InnoDB的区别](#jump4)
## [锁机制与InnoDB锁算法](#jump5)
## [ACID特性](#jump6)
## [并发事务带来哪些问题](#jump7)
## [事务隔离级别](#jump8)
## [数据库索引的类型(B+树)](#jump9)


### 外键的优点和缺点
<span id="jump1">

__优点__：
1. 保证了数据库数据的一致性和完整性
2. 级联操作方便，减轻了程序代码量

__缺点__：
1. 增加了复杂性：a.每次做delete或者update都必须考虑外键约束，会导致开发的时候很痛苦，测试数据极为不方便；b.外键的主从关系是顶的，假如需求有变化，数据库中的这个字段根本不需要和其他表有关联的话就会增加很多麻烦。
2. 增加了额外工作：数据库需要增加维护外键的工作，比如当我们做一些涉及外键字段的增，删，更新操作之后，需要触发相关操作去检查，保证数据的一致性和正确性，这样不得不消耗资源。
3. 对分库分表很不友好：因为分库分表下外键是无法生效的。
4. 外键还会因为需要请求对其他表内部加锁而容易出现死锁的情况。
</span>

### 数据库范式
<span id="jump2">

* 1NF：属性不可再分
* 2NF：在1NF的基础之上，消除了非主属性对码的部分函数依赖
* 3NF：在2NF之上，消除了非主属性对码的传递函数依赖

* __函数依赖__：在一张表中，在属性X的值确定的情况下，必定能确定属性Y的值，那么就可以说Y函数依赖于X，写作X→Y。
* __部分函数依赖__：如果X→Y，并且存在X的一个真子集X0，使得X0→Y，则称Y对X部分函数依赖。比如学生基本信息表R中(学号，身份证号，姓名)当然学号属性的取值是唯一的，在R关系中，(学号，身份证号)→(姓名)，(学号)→(姓名)，(身份证号)→(姓名)；所以姓名部分函数依赖与(学号，身份证号)。
* __完全函数依赖__：在一个关系中，若某个非主属性数据项依赖于全部关键字称之为完全函数依赖。比如学生基本信息表R中(学号，班级，姓名)假设不用的班级学号有相同的，班级内学号不能相同，在R关系中，(学号，班级)→(姓名)，但是(学号)→(姓名)不成立，(班级)→(姓名)不成立，所以姓名完全函数依赖与(学号，班级)。
* __传递函数依赖__：在关系模式R(U)中，设X，Y，Z是U的不同的属性子集，如果X确定Y、Y确定Z，且有X不包含Y，Y不确定X，(X∪Y)∩Z=空集合，则称Z传递函数依赖与X。传递函数依赖会导致数据冗余和异常。传递函数依赖的Y和Z自己往往同属于某一个事物，因此可将其合并放到一个表中。比如在关系R(学号，姓名，系名，系主任)中，学号→系名，系名→系主任，所以存在非主属性系主任对于学号的传递函数依赖。

</span>

### 数据库设计分为哪几步
<span id="jump3">

1. __需求分析__：分析用户的需求，包括数据、功能和性能需求。
2. __概念结构设计__：主要采用E-R模型进行设计，包括画E-R图。
3. __逻辑结构设计__：通过将E-R图转换成表，实现从E-R模型到关系模型的转换。
4. __物理结构设计__：主要是为所设计的数据库选择合适的存储结构和存取路径。
5. __数据库实施__：包括编程、测试和试运行。
6. __数据库的运行和维护__：系统的运行与数据库的日常维护。
</span>

### MyISAM和InnoDB的区别
<span id="jump4">

1. MyISAM只有表级锁，而InnoDB支持行级锁和表级锁，默认为行级锁。也就是说，MyISAM一锁就是锁住了整张表，这是InnoDB在并发写的时候，性能更好了。
2. MyISAM不提供事务支持。InnoDB提供事务支持，具有提交(commit)和回滚(rollback)事务的能力。
3. MyISAM不支持外键，InnoDB支持外键。
4. MyISAM不支持数据库异常崩溃后的安全恢复，而InnoDB支持。使用InnoDB的数据库在异常崩溃后，数据库重新启动的时候会保证数据库恢复到崩溃前的状态，这个恢复的过程依赖于redo log。
* MySQL InnoDB引擎使用redo long保证事务的持久性，使用undo log来保证事务的原子性。
* MySQL InnoDB引擎通过锁机制、MVCC等手段来保证事务的隔离性(默认支持的隔离级别是REPEATABLE-READ)。
* 保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。

5. MyISAM不支持MVCC，而InnoDB支持。
</span>

### 锁机制与InnoDB锁算法
<span id="jump5">

__MyISAM和InnoDB存储引擎使用的锁__：
* MyISAM采用表级锁。
* InnoDB支持行级锁和表级锁，默认为行级锁。

__表级锁和行级锁__：
* __表级锁__：MySQL中锁定粒度最大的一种锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁块，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM和InnoDB引擎都支持表级锁。
* __行级锁__：MySQL中锁定粒度最小的一种锁，只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。

__InnoDB存储引擎的锁的算法有三种__：
* Record lock：记录锁，单个行记录上的锁
* Gap lock：间隙锁，锁定一个范围，不包括记录本身
* Next-key lock：record+gap临键锁，锁定一个范围，包含记录本身。

</span>

### ACID特性
<span id="jump6">

1. __原子性__：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用。
2. __一致性__：执行事务前后，数据保持一致，例如保持一致，例如转账业务中，无论事务是否成功，转账这和收款人的总额应该是不变的。
3. __隔离性__：并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的。
4. __持久性__：一个事务被提交之后，它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。

MySQL InnoDB引擎使用redo log保证事务的持久性，使用undo log来保证事务的原子性。

MySQL InnoDB引擎通过 __锁机制、MVCC__ 等手段来保证事务的隔离性(默认支持的隔离级别是REPEARABLE-READ)。

保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。
</span>

### 并发事务带来哪些问题
<span id="jump7">

* __脏读__：当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。
* __丢失修改__：指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。例如：事务1读取某表中的数据A=20，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失。
* __不可重复读__：指在一个事务内多次读同一数据。这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。
* __幻读__：幻读与不可重复读类似。它发生在一个事务(T1)读取了几行数据，接着另一个并发事务(T2)插入了一些数据时。在随后的查询中，第一个事务(T1)就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。

__不可重复读和幻读区别__：
不可重复读的重点是修改比如多次读取一条记录发现其中某些列的值被修改，幻读的重点在于新增或者删除比如多次查询同一条查询语句时，记录发现记录增多或减少了。
</span>

### 事务隔离级别
<span id="jump8">

* __READ-UNCOMMITTED(读取未提交)__：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。
* __READ-COMMITTED(读取已提交)__：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。
* __REPEATABLE-READ(可重复读)__：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。
* __SERIALIZABLE(可串行化)__：最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。

MySQL默认隔离级别REPEATABLE-READ(可重读)。MySQL InnoDB的REPEATABLE-READ(可重读)并不保证避免幻读，需要应用使用加锁读来保证。而这个加锁读使用到的机制就是Next-Key Locks。
因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是READ-COMMITTED，但是InnoDB存储引擎默认使用REPEATABLE-READ并不会有任何性能损失。
InnoDB存储引擎在分布式事务的情况下一般会用到SERIALIZABLE隔离级别。
</span>

### 数据库索引的类型
<span id="jump9">

* __唯一索引__：唯一索引是不允许其中任何两行具有相同索引值的索引。当现有数据中存在重复的键值时，大多数数据库不允许将新创建的唯一索引与表一起保存。数据库还可能防止添加将在表中创建重复键值的新数据。例如，如果在employee表中职员的姓上创建了唯一索引，则任何两个员工都不能同性。
* __主键索引__：数据库中经常有一列或列组合，其值唯一标识表中的每一行。该列称为表的主键。在数据库关系图中为表定义主键自动创建主键索引，主键索引是唯一索引的特定类型。该索引要求主键中的每个值都唯一。在查询中使用主键索引时，它允许对数据的快速访问。
* __聚集索引__：在聚集索引中，表中行的物理顺序与键值的逻辑顺序相同。一个表只能包含一个聚集索引。如果某索引不是聚集索引，则表中行的物理顺序与键值的逻辑顺序不匹配。与非聚集索引相比，聚集索引通常提供更快的数据访问速度。

索引的底层数据结构时B+树。树最开始是为了解决某种系统中，查询效率低的问题。B树最开始起源于的是二叉树，二叉树是只有左右孩子的树，当数据量大的时候，二叉树的节点越多，当从根节点开始搜索的时候，影响查询效率。如果这些节点存储在外存储器的话，每访问一个节点，相当于进行了一次I/O操作。

__B+树的特点：__
1. 中间元素不存数据，只是当索引用，所有数据都保存在叶子节点中。
2. 所有的中间节点在子结点中要么是最大的元素要么是最小的元素。
3. 叶子节点包含所有的数据，和指向这些元素的指针，而且叶子节点的元素形成了自小向大的链表。

__B+树优势：__
1. 单个节点可以存储更多的数据，减少I/O的次数。
2. 查找性能更稳定，因为都是要查找到叶子节点。
3. 叶子节点形成了有序链表，便于查询。
</span>



























