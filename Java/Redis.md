## [Redis的数据类型](#jump1)
## [Redis和Memcached的区别和共同点](#jump2)
## [Redis使用场景](#jump3)
## [Redis数据淘汰策略](#jump4)
## [Redis持久化](#jump5)
## [跳跃表](#jump6)


### Redis的数据类型
<span id="jump1">

|__数据类型__|__可以存储的值__|__操作__|
|:----:|:----:|:----:|
|String|字符串、整数或者浮点数|对整个字符串或者字符串的其中一部分执行操作</br>对整数和浮点数执行自增或者自减操作
|List|列表|从两端压入或者弹出元素</br>对单个或者多个元素进行修剪</br>只保留一个范围内的元素
|Set|无序集合|添加、获取、移除单个元素</br>检查一个元素是否存在于集合中</br>只保留一个范围内的元素
|Hash|包含键值对的无序散列表|添加、获取、移除单个键值对</br>获取所有键值对</br>检查某个键是否存在
|Zset|有序集合|添加、获取、删除元素</br>根据分值范围或者成员来获取元素</br>计算一个键的排名
</span>

### Redis和Memcached的区别和共同点
<span id="jump2">

__共同点__：
1. 都是基于内存的数据库，一般都用来当做缓存来用。
2. 都有过期策略。
3. 两者的性能非常高。

__区别__：
1. Redis支持更丰富的数据类型(支持更复杂的应用场景)。Redis支持上述数据结构的存储。Memcached只支持简单的k/v数据类型。
2. Redis支持数据的持久化，可以将内存中数据保持在磁盘中，重启的时候可以再次加载使用，而Memcached把数据全部存在内存之中。
3. Redis有灾难恢复机制。因为可以把缓存中的数据持久化到磁盘上。
4. Redis在服务器内存使用完之后，可以将不用的数据放在磁盘上。但是，Memcached在服务器内存使用完之后，就直接报异常。
5. Memcached没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；但是Redis目前是原生支持cluster模式的。
6. Memcached是多线程的，非阻塞IO复用的网络模型；Redis使用单线程的多路IO复用模型。
7. Redis支持发布订阅模型、Lua脚本、事务等功能，支持更多的编程语言；而Memcached不支持。
8. Memcached过期数据的删除策略只用了惰性删除，而Redis同时使用了惰性删除与定期删除。
</span>

### Redis使用场景
<span id="jump3">

__计数器__：可以对String进行自增自减运算，从而实现计数器功能。
Redis这种内存型数据库的读写性能非常高，很适合存储频繁读写的计数量。
__缓存__：将热点数据放入内存中，设置内存的最大使用量以及淘汰策略来保证缓存的命中率。
__消息队列__：List是一个双向链表，可以通过lpush和rpop写入和读取消息，不过最好使用Kafka、RabbitMQ等消息中间件。
__分布式锁__：分布式情况下，无法使用单机环境下的锁来对多个节点上的进程进行同步。可以使用Redis自带的SETNX命令实现分布式锁，除此之外，还可以使用RedLock分布式锁实现。
__会话缓存__：可以使用Redis来统一存储多台应用服务器的会话信息。当应用服务器不再存储用户的会话信息，也就不再具有状态，一个用户可以请求任意一个应用服务器，从而更容易实现高可用性以及可伸缩性。
</span>

### Redis数据淘汰策略
<span id="jump4">

|__策略__|__描述__|
|:----:|:----:|
|volatile-lru|从已设置过期时间的数据集中挑选最新最少使用的数据淘汰|
|volatile-ttl|从已设置过期时间的数据集中挑选将要过期的数据|
|volatile-random|从已设置过期时间的数据集中任意选择数据淘汰|
|allkeys-lru|从所有数据集中挑选最近最少使用的数据淘汰|
|allkeys-random|从所有数据集中任意选择数据淘汰|
|noeviction|禁止驱数据|

</span>

### Redis持久化
<span id="jump5">

__RDB持久化__：将某个时间点的所有数据都存放到硬盘上。可以将快照复制到其它服务器从而创建具有相同数据的服务器副本。如果系统发生故障，将会丢失最后一次创建快照之后的数据。如果数据量很大，保存快照的时间会很长。

__AOF持久化__：将写命令添加到AOF文件的末尾。使用AOF持久化需要设置同步选项，从而确保写命令同步到磁盘文件上的时机。这是因为对文件进行写入并不会马上将文件同步到磁盘，而是先存到缓冲区，然后由操作系统决定什么时候同步到磁盘。

|选项|同步频率|影响|
|:----:|:----:|:----:|
|always|每个写命令都同步|严重减低服务器的性能|
|everysec|每秒同步一次|可以保证系统崩溃时只会丢失一秒左右的数据，并且Redis每秒执行一次同步对服务器性能几乎没有任何影响。
|no|让操作系统来决定何时同步|并不能给服务器性能带来多大的提升，也会增加系统崩溃时数据丢失的数量。

随着服务器写请求的增多，AOF文件会越来越大。Redis提供了一种将AOF重写的特性，能够去除AOF文件中的冗余写命令。
</span>

### 跳跃表
<span id="jump6">

跳跃表是有序集合的底层实现之一。是基于多指针有序链表实现的，可以看成多个有序链表。查找时，从上层指针开始查找，找到对应的区间之后再到下一层查找。
<img src="D:\Code\Notebook\Java\fig\jumptable.png" width="50%">
与红黑树相比，跳跃表具有一下优点：

* 插入速度非常快，因为不需要旋转等操作来维护平衡性。
* 更容易实现。
* 支持无锁操作。
</span>













